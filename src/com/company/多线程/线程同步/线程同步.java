package com.company.多线程.线程同步;

/**
 * 1. 两种编程模型(以t1和t2为例):
 *    (1) 异步编程模型: t1线程执行t1的, t2线程执行t2的, 两个线程之间谁也不等谁.
 *    (2) 同步编程模型: 如果t2线程执行, t1线程必须等t2线程执行结束之后, t1线程才能执行, 这是同步编程模型.
 *
 * 2. 什么时候要同步呢?(多线程中修改共享数据) 为什么要引入线程同步呢?(数据安全)
 *    (1) 作用: 为了数据安全. 尽管应用程序的使用率降低, 但是为了保证数据是安全的, 必须加入线程同步机制. 线程同步机制使程序变成了(等同)单线程.
 *    (2) 什么条件下要使用线程同步:
 *        1> 第一: 必须是多线程环境;
 *        2> 第二: 多线程环境共享同一个数据;
 *        3> 第三: 共享的数据涉及到修改操作.
 *
 * 3. 使用线程同步(synchronized关键字):
 *    (1) 语法: synchronized(共享对象){} : 把需要同步的代码放到同步语句块中. 大括号中只能放一个线程.
 *    (2) 注意: synchronized关键字添加到成员方法上, 线程拿走的也是this的对象锁.
 *    (3) 原理: t1线程和t2线程
 *        1> t1线程执行到此处, 遇到了synchronized关键字, 就会去找this的对象锁, 如果找到this对象锁, 则进入同步语句块中执行程序,
 *           当同步语句块中的代码执行结束后, t1线程归还this的对象锁.
 *        2> 在t1线程执行同步语句块的过程中, 如果t2线程也过来执行代码, 也遇到synchronized关键字, 所以也去找this的对象锁, 但是该对象锁被t1持有, 只能在这等待this对象的归还.
 *    (4) synchronized关键字有两种使用方式: 一种是加载到同步语句块中; 另一种是加载方法上. 推荐使用第一种方式, 因为方法中可能有需要同步的代码.
 *    (5) 如果两个线程共享一个对象, 则将该对象作为构造方法的参数传入来实现共享.
 *    (6) 类锁, 类只有一个, 所以锁是类级别的, 只有一个.
 *    (7) 总结: 线程同步汇总一共有两种锁, 一种是对象锁, 对象级别的, 加到成员方法或者同步语句块上, 但是如果加到方法上, 则该方法中所有代码都需要同步, 加到代码块上则只是让需要的代码进行同步,
 *              该方法中的其他代码不影响, 一个对象只有一个对象锁, 当多个线程访问该对象中的同步语句块时, 就会触发该对象锁, 实现同步;
 *              另一种是类锁, 类级别的, 加到静态方法上, 一个类只有一个类锁, 当多个线程方法访问该类中的同步代码块时, 就会触发类锁, 实现同步.
 *    (8) 关于对象锁和类锁的总结: 在线程(主线程和子线程)中放的是对共享对象的操作(对共享对象修改), 同步代码块是共享对象的方法(线程中要调用的方法, 当然要先创建对象, 作为构造参数实现).
 *                              给哪个方法加synchronized关键字, 则当线程调用该方法时就会找对象锁/类锁, 如果哪个方法没有加该关键字, 则当线程调用该方法时不会找类锁/对象锁.
 *                              对于关键字synchronized的位置, 可以在共享对象的方法上, 也可以在线程的run方法中, 因为即使加在共享对象的方法上, 也是要当线程的run方法中调用该对象的方法时, 才起作用. 所以说到底可以说就是在run方法中.
 *
 *
 * 4. 死锁
 *
 */
public class 线程同步 {
}

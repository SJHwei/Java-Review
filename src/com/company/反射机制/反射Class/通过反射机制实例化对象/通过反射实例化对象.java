package com.company.反射机制.反射Class.通过反射机制实例化对象;

/**
 * @author ShiWei
 * @date 2021/2/2 - 17:28
 *
 * 1. 通过反射实例化对象
 *    (1) 方式: 使用Class类中的一个成员方法: newInstance().
 *              该方法只会调用类的无参数构造方法. 所以要把类的无参数构造方法写出来.
 *              如果只定义类的有参数构造方法, 那么无参数构造方法就没有了, 就会有异常.
 *    (2) 注意: 如果构造方法发生了重载, 就要创建无参数构造方法, 否则会报错.
 *    (3) 总结: 有很多字节码文件, forName()方法作用就是将指定的字节码文件装载到JVM(方法区)中(类加载).
 *              newInstance()方法作用是通过该类的无参数构造方法创建对象.
 *              所以forName导致类加载, newInstance调用该类的无参数构造方法.
 *
 * 2. 通过读取属性文件实例化对象
 *    (1) 作用: 测试反射机制的灵活性
 *    (2) 具体: 如果在classinfo.properties属性配置文件中修改值, 则这段代码最后产生的对象类型也会变化.
 *              java代码写一遍, 在不改变java源代码的基础上, 可以做到不同对象的实例化, 非常之灵活.
 *    (3) 符合OCP原则: 对外开放, 对修改关闭.
 *
 * 3. 读取属性文件的三种方式:
 *    (1) IO流(获取绝对路径+使用IO流, 然后使用properties);
 *    (2) 以流的形式直接返回(等价于上面两个步骤, 然后使用Properties);
 *    (3) 资源绑定器.
 *
 * 4. 通过读取属性文件实例化对象中涉及的两个知识点:
 *    (1) 只让静态代码块执行可以使用forName();
 *    (2) 获取类路径下文件的绝对路径.
 *
 * 5. 深入forName()静态方法
 *    (1) 应用: 只让静态代码块执行可以使用forName()方法.
 *              如果只是希望一个类的静态代码块执行, 其他代码一律不执行.
 *              可以使用: Class.forName("完整类名").
 *    (2) 原理: 这个方法的执行会导致类加载, 类加载时静态代码执行.
 *
 * 6. 获取类路径下文件的绝对路径
 *    (1) 问题: 怎么获取一个文件的绝对路径. 以下讲解的这种方式是通用的.
 *    (2) 重点:
 *        1> IDEA中默认的当前路径是project的根.
 *        2> 类路径: 放在src下的都是类路径, src是类的根路径.
 *        3> 获取一个文件的绝对路径的通用方式:
 *           String path = Thread.currentThread().getContextClassLoader().getRsource("...(默认从类的根路径下作为起点)").getPath();
 *        4> 前提: 这个文件必须在类路径下.
 *
 * 7. 以流的形式直接返回
 *
 * 8. 资源绑定器
 *    (1) 说明: java.util包下提供了一个资源绑定器, 便于获取属性配置文件中的内容.
 *    (2) 重点:
 *        1> 只能绑定xxx.propertes文件;
 *        2> 该文件必须放在类路径下;
 *        3> 往方法中填路径名时路径后面的扩展名不能写.
 *
 * 9. 类加载器
 *    (1) 概念(什么是类加载器):
 *        1> 专门加载类的命令/工具;
 *        2> ClassLoader.
 *    (2) 分类(JDK中自带了3个类加载器):
 *        1> 启动类加载器;
 *        2> 扩展类加载器;
 *        3> 应用类加载器.
 *    (3) 实例: 假设有这样一段代码(String s = "abc")
 *        1> 代码开始之前会将所需要类全部加载到JVM中. 通过类加载器加载, 看到以上代码, 类加载器会找String.class文件, 找到就加载, 那么是怎么样进行加载的呢?
 *        2> 首先通过启动类加载器加载. 注意: 启动类加载器专门加载jdk/jre/lib/rt.jar, rt.jar中都是jdk最核心的类库.
 *        3> 如果通过启动类加载器加载不到的时候, 会通过扩展类加载器加载. 注意: 扩展类加载器专门加载jdk/jre/lib/ext/*.jar.
 *        4> 如果扩展类加载器没有加载到, 那么会通过应用类加载器加载. 注意: 应用类加载器专门加载classpath中的类(class文件).
 *    (4) 双亲委派机制(为了保证类加载器的安全):
 *        * 优先从启动类加载器中加载, 这个称为父, 父无法加载到, 再从扩展类加载器汇总加载, 这个称为母. 双亲委派. 如果都加不到, 才会考虑从应用类加载器中加载. 直到加载到为止.
 */
public class 通过反射实例化对象 {
}
